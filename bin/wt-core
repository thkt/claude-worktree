#!/usr/bin/env zsh
set -euo pipefail

log() { echo "▸ $*" >&2; }
err() { echo "error: $*" >&2; exit 1; }

validate_git_repo() {
  git rev-parse --show-toplevel &>/dev/null || err "not a git repository"
}

get_repo_info() {
  REPO_ROOT="$(git rev-parse --show-toplevel)"
  local git_common
  git_common="$(git rev-parse --git-common-dir 2>/dev/null)"
  if [ -n "$git_common" ] && [[ "$git_common" != "$REPO_ROOT/.git" ]]; then
    local main_git_dir
    main_git_dir="$(cd "$git_common" && pwd -P)"
    REPO_ROOT="$(dirname "$main_git_dir")"
  fi
  WT_BASE="$(dirname "$REPO_ROOT")/worktrees"
}

resolve_base() {
  local explicit="${1:-}"
  if [ -n "$explicit" ]; then
    git rev-parse --verify "$explicit" &>/dev/null || err "branch not found: $explicit"
    echo "$explicit"
    return
  fi
  for candidate in main develop master; do
    if git rev-parse --verify "$candidate" &>/dev/null; then
      echo "$candidate"
      return
    fi
  done
  err "base branch not found (tried: main, develop, master)"
}

validate_branch_name() {
  local branch="$1"
  [[ "$branch" != -* ]] || err "branch name cannot start with -"
  [[ "$branch" != *..* ]] || err "invalid branch name: $branch"
  [[ "$branch" != */ ]] || err "invalid branch name: $branch"
  [[ ! "$branch" =~ [[:cntrl:][:space:]\~\^\:\?\*\[\\] ]] || err "invalid branch name: $branch"
}

get_fuzzy_finder() {
  local finder="${WT_FUZZY_FINDER:-}"
  if [ -n "$finder" ]; then
    [[ "$finder" =~ ^[a-zA-Z0-9_-]+$ ]] || err "invalid fuzzy finder name: $finder"
    command -v "$finder" &>/dev/null || err "fuzzy finder not found: $finder"
    echo "$finder"
  elif command -v sk &>/dev/null; then
    echo "sk"
  elif command -v fzf &>/dev/null; then
    echo "fzf"
  else
    return 1
  fi
}

fuzzy_select() {
  local items="$1"
  local finder
  finder="$(get_fuzzy_finder)" || {
    echo "$items" >&2
    err "install sk or fzf for interactive selection"
  }
  echo "$items" | "$finder"
}

typeset -ga _WT_BRANCHES=()
typeset -gA _WT_PATHS=()

_get_wt_path() {
  typeset -gA _WT_PATHS
  local key="$1"
  if (( ${+_WT_PATHS[$key]} )); then
    echo "${_WT_PATHS[$key]}"
  fi
  return 0
}

parse_worktrees() {
  typeset -gA _WT_PATHS
  _WT_BRANCHES=()
  _WT_PATHS=()
  local wt_path=""
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      wt_path="${line#worktree }"
    elif [[ "$line" == branch\ refs/heads/* ]]; then
      local name="${line#branch refs/heads/}"
      if [[ "$wt_path" == "$REPO_ROOT" ]]; then
        _WT_BRANCHES=("$name" "${_WT_BRANCHES[@]}")
        _WT_PATHS[$name]=$wt_path
      elif [[ "$wt_path" == "$WT_BASE/"* ]]; then
        _WT_BRANCHES+=("$name")
        _WT_PATHS[$name]=$wt_path
      fi
    elif [ -z "$line" ]; then
      wt_path=""
    fi
  done < <(git worktree list --porcelain)
}

list_worktree_branches() {
  parse_worktrees
  [ "${#_WT_BRANCHES[@]}" -gt 0 ] || err "no worktrees found"
  printf '%s\n' "${_WT_BRANCHES[@]}"
}

copy_env_files() {
  local repo_root="$1" wt_dir="$2"
  local -a files=()
  local f
  for f in "$repo_root"/**/.env*(N.); do
    [[ "$f" == */.git/* || "$f" == */node_modules/* ]] && continue
    files+=("$f")
  done

  [ "${#files[@]}" -eq 0 ] && return 0

  log "Found ${#files[@]} .env file(s):"
  local rel
  for f in "${files[@]}"; do
    rel="${f#"$repo_root"/}"
    echo "  $rel" >&2
  done

  if [ -t 2 ]; then
    printf "Copy to new worktree? [Y/n] " >&2
    local reply
    read -r reply </dev/tty || reply=""
    [[ "$reply" =~ ^[Nn] ]] && { log "Skipped .env copy"; return 0; }
  fi

  local copied=0 dest
  for f in "${files[@]}"; do
    rel="${f#"$repo_root"/}"
    dest="$wt_dir/$rel"
    mkdir -p "$(dirname "$dest")"
    cp -p "$f" "$dest"
    copied=$((copied + 1))
  done
  log "Copied $copied .env file(s)"
}

run_setup() {
  local wt_dir="$1"
  (
    cd "$wt_dir"

    if [ -f pnpm-lock.yaml ]; then
      log "Running pnpm install..."
      pnpm install >&2 || { log "pnpm install failed"; exit 1; }
    elif [ -f package-lock.json ]; then
      log "Running npm install..."
      npm install >&2 || { log "npm install failed"; exit 1; }
    elif [ -f yarn.lock ]; then
      log "Running yarn install..."
      yarn install >&2 || { log "yarn install failed"; exit 1; }
    elif [ -f bun.lockb ]; then
      log "Running bun install..."
      bun install >&2 || { log "bun install failed"; exit 1; }
    fi

    if [ -f .mise.toml ] || [ -f .tool-versions ]; then
      log "Running mise install..."
      mise install >&2 || { log "mise install failed"; exit 1; }
    fi
    if [ -f .envrc ]; then
      log "Running direnv allow..."
      direnv allow >&2 || { log "direnv allow failed"; exit 1; }
    fi
  )
}

cmd_new() {
  local no_env=0
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --no-env) no_env=1; shift ;;
      --) shift; break ;;
      *) err "unknown option: $1" ;;
    esac
  done

  [ -z "${1:-}" ] && { echo "usage: wt new [--no-env] <branch> [base]" >&2; exit 1; }
  validate_git_repo
  get_repo_info
  git worktree prune || log "warning: git worktree prune failed"

  local branch="$1"
  validate_branch_name "$branch"
  local dir_name="${branch//\//-}"
  local wt_dir="$WT_BASE/$dir_name"

  if [ -d "$wt_dir" ]; then
    local existing_branch
    existing_branch="$(git -C "$wt_dir" rev-parse --abbrev-ref HEAD 2>/dev/null)" || existing_branch=""
    if [ -n "$existing_branch" ] && [ "$existing_branch" != "$branch" ]; then
      err "directory collision: $branch maps to same dir as $existing_branch"
    fi
    err "worktree already exists: $wt_dir"
  fi

  local base
  base="$(resolve_base "${2:-}")"

  mkdir -p "$(dirname "$wt_dir")"

  cleanup_wt() {
    if [ -d "$wt_dir" ]; then
      git worktree remove "$wt_dir" 2>/dev/null ||
        log "warning: failed to clean up worktree at $wt_dir"
    fi
  }
  trap cleanup_wt EXIT

  if git rev-parse --verify "$branch" &>/dev/null; then
    log "Checking out existing branch: $branch"
    git worktree add "$wt_dir" "$branch" >&2
  else
    log "Creating new branch: $branch (from $base)"
    git worktree add "$wt_dir" -b "$branch" "$base" >&2
  fi

  trap - EXIT

  if [ "$no_env" -eq 0 ]; then
    copy_env_files "$REPO_ROOT" "$wt_dir" || log "warning: .env copy incomplete"
  fi

  if ! run_setup "$wt_dir"; then
    log "WARNING: setup incomplete — worktree created, run setup manually"
  fi

  echo "$wt_dir"
}

cmd_cd() {
  validate_git_repo
  get_repo_info

  local branch="${1:-}"
  if [ -z "$branch" ]; then
    local branches
    branches="$(list_worktree_branches)"
    branch="$(fuzzy_select "$branches")"
    [ -n "$branch" ] || err "no worktree selected"
  fi
  parse_worktrees

  local wt_dir
  wt_dir="$(_get_wt_path "$branch")"
  [ -n "$wt_dir" ] || err "worktree not found: $branch"
  echo "$wt_dir"
}

build_ls_lines() {
  local current_dir="$1"
  local max_branch_len=0
  for name in "${_WT_BRANCHES[@]}"; do
    [ "${#name}" -gt "$max_branch_len" ] && max_branch_len=${#name}
  done

  local wt_dir resolved_wt mark changes status_text ahead behind msg
  for name in "${_WT_BRANCHES[@]}"; do
    wt_dir="$(_get_wt_path "$name")"
    resolved_wt="$(cd "$wt_dir" 2>/dev/null && pwd -P)" || continue

    mark="  "
    [[ "$current_dir/" == "$resolved_wt/"* ]] && mark="★ "

    local status_output
    status_output="$(git -C "$wt_dir" status --porcelain -b 2>/dev/null)" || continue
    local -a status_lines=("${(@f)status_output}")
    changes=$(( ${#status_lines[@]} - 1 ))
    if [ "$changes" -eq 0 ]; then
      status_text="clean"
    else
      status_text="${changes} changed"
    fi

    ahead="-" behind="-"
    local header="${status_lines[1]}"
    if [[ "$header" == *"..."* ]]; then
      ahead="0" behind="0"
      [[ "$header" =~ "ahead ([0-9]+)" ]] && ahead="${match[1]}"
      [[ "$header" =~ "behind ([0-9]+)" ]] && behind="${match[1]}"
    fi

    msg="$(git -C "$wt_dir" log -1 --format='%s' 2>/dev/null || echo "(no commits)")"

    printf "%s\t%s%-${max_branch_len}s  %-10s  ↑%s ↓%s  %s\n" \
      "$wt_dir" "$mark" "$name" "$status_text" "$ahead" "$behind" "$msg"
  done
}

present_ls() {
  local -a lines=("${(@f)$(cat)}")
  lines=("${lines[@]:#}")
  local finder=""
  if [ -t 2 ]; then
    if [ -n "${WT_FUZZY_FINDER:-}" ]; then
      finder="$(get_fuzzy_finder)"
    else
      finder="$(get_fuzzy_finder 2>/dev/null)" || finder=""
    fi
  fi

  if [ -n "$finder" ]; then
    printf '%s\n' "${lines[@]}" | "$finder" \
      --delimiter=$'\t' \
      --with-nth=2.. \
      --no-sort \
      --preview='
        dir="{1}"
        printf "\033[1mRecent Commits\033[0m\n"
        printf "────────────────────────────────────────\n"
        git -C "$dir" log --oneline --color=always -10 2>/dev/null || printf "  (no commits)\n"
        printf "\n"
        printf "\033[1mChanges\033[0m\n"
        printf "────────────────────────────────────────\n"
        changes="$(git -C "$dir" status --short 2>/dev/null)"
        if [ -n "$changes" ]; then
          printf "%s\n" "$changes"
        else
          printf "  (clean)\n"
        fi
      ' \
      --preview-window='right:50%:wrap' \
      > /dev/null || true
  else
    local line
    for line in "${lines[@]}"; do
      echo "${line#*	}"
    done
  fi
}

cmd_ls() {
  validate_git_repo
  get_repo_info

  local current_dir
  current_dir="$(pwd -P)"

  parse_worktrees
  [ "${#_WT_BRANCHES[@]}" -gt 0 ] || err "no worktrees found"

  build_ls_lines "$current_dir" | present_ls
}

cmd_rm() {
  validate_git_repo
  get_repo_info

  local branch
  if [ -n "${1:-}" ]; then
    branch="$1"
  else
    local branches
    branches="$(list_worktree_branches)"
    branch="$(fuzzy_select "$branches")"
    [ -n "$branch" ] || err "no worktree selected"
  fi
  parse_worktrees

  local wt_dir
  wt_dir="$(_get_wt_path "$branch")"
  [ -n "$wt_dir" ] || err "worktree not found: $branch"
  [[ "$wt_dir" == "$REPO_ROOT" ]] && err "cannot remove main repository"

  local current_dir
  current_dir="$(pwd -P)"
  local resolved_wt
  resolved_wt="$(cd "$wt_dir" && pwd -P)"
  [[ "$current_dir/" == "$resolved_wt/"* ]] && err "cannot remove current worktree (cd out first)"

  if git -C "$wt_dir" status --short | grep -q .; then
    err "worktree has uncommitted changes: $branch"
  fi

  log "Removing worktree: $branch"
  git worktree remove "$wt_dir" >&2

  log "Deleting local branch: $branch"
  git branch -d "$branch" 2>/dev/null || log "Branch not deleted (not fully merged)"

  git worktree prune
  log "Done"
}

usage() {
  cat >&2 <<EOF
usage: wt <command> [args]

commands:
  new [--no-env] <branch> [base]   Create a new worktree
  cd  [branch]                     Switch to a worktree
  ls                               List worktrees
  rm  [branch]                     Remove a worktree
EOF
  exit 1
}

main() {
  case "${1:-}" in
    new) cmd_new "${@:2}" ;;
    cd)  cmd_cd "${@:2}" ;;
    ls)  cmd_ls "${@:2}" ;;
    rm)  cmd_rm "${@:2}" ;;
    *)   usage ;;
  esac
}

main "$@"
